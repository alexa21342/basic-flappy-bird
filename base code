<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Mario-like Platformer (Vanilla JS)</title>
  <style>
    :root { --bg:#0f172a; --fg:#e5e7eb; --ui:#111827; --accent:#22d3ee; }
    html,body{height:100%;margin:0;background:radial-gradient(60% 60% at 50% 40%,#0b1220 0,#0a0f1c 40%,#060913 100%);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial}
    .wrap{display:grid;place-items:center;height:100%;gap:12px}
    canvas{background:linear-gradient(#60a5fa 0%,#93c5fd 60%,#9ae6b4 60%,#65a30d 100%);border-radius:14px;box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .hud{display:flex;gap:16px;align-items:center;font-weight:600;opacity:.9}
    .btn{cursor:pointer;padding:8px 12px;border-radius:999px;border:1px solid #334155;background:#0b1220;color:var(--fg)}
    .btn:hover{background:#111827}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="800" height="480" aria-label="Platformer game canvas" role="img"></canvas>
    <div class="hud">
      <button class="btn" id="restart" title="Restart (R)">Restart</button>
      <span>Controls: ← → to move, Space/Z to jump, R to restart</span>
    </div>
  </div>

  <script>
  (()=>{
    const TILE = 32;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restart');

    // Camera (in world pixels)
    const cam = { x:0, y:0, w:canvas.width, h:canvas.height };

    // Simple level legend:
    // X = solid ground, # = brick (solid), P = pipe (solid), g = goomba enemy, o = coin, F = flag (win)
    // = empty, ? = question block (coin)
    const level = [
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                                                                                ",
      "                       o        o                    o                           ",
      "              ###                   ###                                         ",
      "         o         ?             o      ?             o                          ",
      "                                                                                ",
      "     XX                 XX                XX                 XX                  ",
      "                                                                                ",
      "                                                                                ",
      "  P        g                     g                    g                          ",
      "  P                                                                                ",
      "  P                     ###                         ###                           ",
      "  PX        o                o            o                 o                     ",
      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   F  ",
      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    ];

    const H = level.length;
    const W = level[0].length;

    function tileAt(tx,ty){
      if (ty < 0 || ty >= H || tx < 0) return 'X'; // left/out is solid to avoid falling forever
      if (tx >= W) return ' ';
      return level[ty].charAt(tx);
    }

    function isSolid(ch){ return ch==='X' || ch==='#' || ch==='P'; }

    const keys = { left:false, right:false, jump:false, jumpPressed:false };
    addEventListener('keydown', e=>{
      if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = true;
      if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right = true;
      if (e.code==='Space' || e.code==='KeyZ' || e.code==='KeyW' || e.code==='ArrowUp') { if(!keys.jump) keys.jumpPressed=true; keys.jump=true; }
      if (e.code==='KeyR'){ reset(); }
    });
    addEventListener('keyup', e=>{
      if (e.code==='ArrowLeft' || e.code==='KeyA') keys.left = false;
      if (e.code==='ArrowRight'|| e.code==='KeyD') keys.right = false;
      if (e.code==='Space' || e.code==='KeyZ' || e.code==='KeyW' || e.code==='ArrowUp') keys.jump=false;
    });

    // Entities
    const player = { x:2*TILE, y:12*TILE, w:20, h:28, vx:0, vy:0, onGround:false, coins:0, dead:false, win:false };

    const enemies = []; // goombas
    const coins = [];
    const qblocks = new Map(); // "ty,tx" -> used:boolean
    let flagX = (W-2)*TILE;

    // Populate from level
    function build(){
      enemies.length=0; coins.length=0; qblocks.clear();
      for (let ty=0; ty<H; ty++){
        for (let tx=0; tx<W; tx++){
          const ch = level[ty][tx];
          const x = tx*TILE, y = ty*TILE;
          if (ch==='g') enemies.push({x:x+6,y:y+8,w:20,h:20,vx:-0.5,alive:true});
          if (ch==='o') coins.push({x:x+8,y:y+8,w:16,h:16,collected:false,spin:0});
          if (ch==='?') qblocks.set(`${ty},${tx}`, false);
          if (ch==='F') flagX = tx*TILE;
        }
      }
    }

    // Physics constants
    const GRAV = 0.5, JUMP_V = -10.8, MOVE = 0.8, MAXS = 3.0, FRICTION = 0.85;

    function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

    // Tile collision helpers
    function collideRectWorld(rect){
      // Resolve along X then Y
      // X axis
      rect.x += rect.vx;
      let minTx = Math.floor(rect.x / TILE);
      let maxTx = Math.floor((rect.x + rect.w - 1) / TILE);
      let minTy = Math.floor(rect.y / TILE);
      let maxTy = Math.floor((rect.y + rect.h - 1) / TILE);
      // Horizontal collisions
      for (let ty=minTy; ty<=maxTy; ty++){
        for (let tx=minTx; tx<=maxTx; tx++){
          const ch = tileAt(tx,ty);
          if (isSolid(ch)){
            if (rect.vx>0){ rect.x = tx*TILE - rect.w; rect.vx = 0; maxTx = tx-1; }
            else if (rect.vx<0){ rect.x = (tx+1)*TILE; rect.vx = 0; minTx = tx+1; }
          }
        }
      }
      // Y axis
      rect.y += rect.vy;
      minTx = Math.floor(rect.x / TILE);
      maxTx = Math.floor((rect.x + rect.w - 1) / TILE);
      minTy = Math.floor(rect.y / TILE);
      maxTy = Math.floor((rect.y + rect.h - 1) / TILE);
      rect.onGround = false;
      for (let ty=minTy; ty<=maxTy; ty++){
        for (let tx=minTx; tx<=maxTx; tx++){
          let ch = tileAt(tx,ty);
          if (isSolid(ch)){
            if (rect.vy>0){ rect.y = ty*TILE - rect.h; rect.vy=0; rect.onGround=true; }
            else if (rect.vy<0){ rect.y = (ty+1)*TILE; rect.vy=0; 
              // bump blocks
              if (level[ty][tx]==='?') { hitQBlock(tx,ty); }
            }
          }
        }
      }
    }

    function hitQBlock(tx,ty){
      const key = `${ty},${tx}`;
      if (qblocks.get(key)) return; // used
      qblocks.set(key,true);
      // spawn a coin above
      coins.push({x:tx*TILE+8,y:(ty-1)*TILE+8,w:16,h:16,collected:false,spin:0,rise:18});
      // turn into used block '#'
      level[ty] = replaceChar(level[ty], tx, '#');
    }

    function replaceChar(str, idx, ch){ return str.substring(0,idx) + ch + str.substring(idx+1); }

    function reset(){
      player.x=2*TILE; player.y=12*TILE; player.vx=0; player.vy=0; player.coins=0; player.dead=false; player.win=false;
      build();
    }

    build();

    // --- Update loop ---
    function update(){
      if (player.dead || player.win) return;
      // Input → velocity
      if (keys.left)  player.vx = Math.max(player.vx - MOVE, -MAXS);
      if (keys.right) player.vx = Math.min(player.vx + MOVE,  MAXS);
      if (!keys.left && !keys.right) player.vx *= FRICTION;

      // Jump (coyote time and variable jump could be added, keep simple)
      if (keys.jumpPressed && player.onGround){ player.vy = JUMP_V; }
      keys.jumpPressed = false;

      // Gravity
      player.vy += GRAV; if (player.vy>12) player.vy=12;

      collideRectWorld(player);

      // Fell off map
      if (player.y > H*TILE+200) player.dead = true;

      // Enemies
      for (const e of enemies){
        if (!e.alive) continue;
        // Patrol
        e.x += e.vx;
        // turn around at edges / walls
        const aheadX = e.vx>0 ? e.x+e.w+1 : e.x-1;
        const footY = e.y + e.h + 2;
        const tx = Math.floor(aheadX / TILE);
        const ty = Math.floor(footY / TILE);
        const front = tileAt(tx, Math.floor((e.y+e.h/2)/TILE));
        const below = tileAt(tx, ty);
        if (isSolid(front) || !isSolid(below)) e.vx *= -1;

        // Player collision
        if (aabb(player, e)){
          if (player.vy > 0 && player.y + player.h - e.y < 14){
            // Stomp
            e.alive = false; player.vy = -8; player.onGround=false;
          } else {
            // Hurt
            player.dead = true;
          }
        }
      }

      // Coins
      for (const c of coins){
        if (!c.collected && aabb(player,c)){
          c.collected = true; player.coins++;
        }
        if (c.rise!==undefined){ c.y -= 0.8; c.rise -= 0.8; if (c.rise<=0) delete c.rise; }
        c.spin += 0.15;
      }

      // Win at flag
      if (player.x + player.w >= flagX){ player.win = true; }

      // Camera follow
      cam.x = Math.max(0, Math.min(player.x - cam.w*0.35, W*TILE - cam.w));
      cam.y = 0;
    }

    // --- Render ---
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.translate(-cam.x, -cam.y);

      // Background hills
      drawBackground();

      // Level tiles
      for (let ty=0; ty<H; ty++){
        for (let tx=0; tx<W; tx++){
          const ch = level[ty][tx];
          const x = tx*TILE, y = ty*TILE;
          switch(ch){
            case 'X': drawBlock(x,y,'#16a34a','#15803d'); break;
            case '#': drawBlock(x,y,'#eab308','#a16207'); break;
            case 'P': drawPipe(x,y); break;
            case '?': drawQuestion(x,y, qblocks.get(`${ty},${tx}`)); break;
            case 'F': drawFlag(x,y); break;
          }
        }
      }

      // Coins
      for (const c of coins){ if (c.collected) continue; drawCoin(c.x, c.y, c.spin); }

      // Enemies
      for (const e of enemies){ if (!e.alive) continue; drawGoomba(e.x,e.y); }

      // Player
      drawPlayer(player.x, player.y);

      ctx.restore();

      // HUD
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(10,10,170,50);
      ctx.fillStyle = '#e5e7eb';
      ctx.font = 'bold 18px system-ui';
      ctx.fillText(`Coins: ${player.coins}`, 20, 38);

      if (player.dead || player.win){
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#e5e7eb';
        ctx.textAlign = 'center';
        ctx.font = 'bold 36px system-ui';
        ctx.fillText(player.win? 'You reached the flag! 🎉' : 'You Died! 💀', canvas.width/2, canvas.height/2 - 10);
        ctx.font = '18px system-ui';
        ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 26);
        ctx.textAlign = 'start';
      }
    }

    function drawBackground(){
      const skyTop = '#87ceeb', skyBottom = '#bfefff';
      // ground band already in CSS; draw parallax hills
      const t = performance.now()*0.0002;
      for (let layer=0; layer<3; layer++){
        ctx.fillStyle = `hsl(${120+layer*10} 40% ${30+layer*6}%)`;
        const yBase = 360 + layer*8;
        ctx.beginPath();
        ctx.moveTo(cam.x, 480);
        for (let x=cam.x-50; x<cam.x+cam.w+50; x+=10){
          const y = yBase + Math.sin((x*0.02)+(t*80)+layer)*10;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(cam.x+cam.w+50, 480);
        ctx.closePath(); ctx.globalAlpha = 0.25 + layer*0.15; ctx.fill(); ctx.globalAlpha = 1;
      }
    }

    function drawBlock(x,y,fill,shadow){
      ctx.fillStyle = fill; ctx.fillRect(x,y,TILE,TILE);
      ctx.fillStyle = shadow; ctx.fillRect(x,y+TILE-6,TILE,6);
      ctx.fillRect(x+TILE-6,y,6,TILE);
    }
    function drawPipe(x,y){
      ctx.fillStyle = '#16a34a'; ctx.fillRect(x,y,TILE,TILE*3);
      ctx.fillStyle = '#15803d'; ctx.fillRect(x-4,y,TILE+8,8);
    }
    function drawQuestion(x,y,used){
      ctx.fillStyle = used? '#eab308' : '#fbbf24'; ctx.fillRect(x,y,TILE,TILE);
      ctx.fillStyle = '#92400e'; ctx.fillRect(x,y+TILE-5,TILE,5);
      if (!used){ ctx.fillStyle = '#7c2d12'; ctx.font='bold 22px system-ui'; ctx.fillText('?', x+10, y+24); }
    }
    function drawFlag(x,y){
      ctx.fillStyle = '#9ca3af'; ctx.fillRect(x+12,y-5,4,TILE+5);
      ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.moveTo(x+16,y+4); ctx.lineTo(x+40,y+12); ctx.lineTo(x+16,y+20); ctx.closePath(); ctx.fill();
    }

    function drawCoin(x,y,spin){
      const r = 8 + Math.sin(spin)*1.5;
      ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.ellipse(x+8,y+8,r,8,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,.2)'; ctx.fillRect(x+2,y+12,12,2);
    }

    function drawGoomba(x,y){
      ctx.fillStyle = '#92400e'; ctx.fillRect(x,y,20,16);
      ctx.fillStyle = '#7f1d1d'; ctx.fillRect(x-2,y+14,24,6);
      ctx.fillStyle = '#111827'; ctx.fillRect(x+4,y+6,4,4); ctx.fillRect(x+12,y+6,4,4);
    }

    function drawPlayer(x,y){
      // Simple Mario-like shape
      ctx.save();
      ctx.translate(x,y);
      // body
      ctx.fillStyle = '#ef4444'; ctx.fillRect(2,0,16,10); // hat
      ctx.fillStyle = '#f59e0b'; ctx.fillRect(6,10,8,8); // face
      ctx.fillStyle = '#ef4444'; ctx.fillRect(0,18,20,10); // torso
      ctx.fillStyle = '#2563eb'; ctx.fillRect(0,28,8,8); ctx.fillRect(12,28,8,8); // legs
      ctx.restore();
    }

    // Main loop
    function loop(){ update(); draw(); requestAnimationFrame(loop); }
    loop();

    restartBtn.addEventListener('click', reset);
    reset();
  })();
  </script>
</body>
</html>

// hi :3
